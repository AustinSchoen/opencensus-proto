<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: opencensus/proto/metrics/v1/metrics.proto

namespace Opencensus\Proto\Metrics\V1\MetricDescriptor;

use UnexpectedValueException;

/**
 * The kind of metric. It describes how the data is reported.
 * A gauge is an instantaneous measurement of a value.
 * A cumulative measurement is a value accumulated over a time interval. In
 * a time series, cumulative measurements should have the same start time,
 * increasing values and increasing end times, until an event resets the
 * cumulative value to zero and sets a new start time for the following
 * points.
 *
 * Protobuf type <code>opencensus.proto.metrics.v1.MetricDescriptor.Type</code>
 */
class Type
{
    /**
     * Do not use this default value.
     *
     * Generated from protobuf enum <code>UNSPECIFIED = 0;</code>
     */
    const UNSPECIFIED = 0;
    /**
     * Integer gauge. The value can go both up and down.
     *
     * Generated from protobuf enum <code>GAUGE_INT64 = 1;</code>
     */
    const GAUGE_INT64 = 1;
    /**
     * Floating point gauge. The value can go both up and down.
     *
     * Generated from protobuf enum <code>GAUGE_DOUBLE = 2;</code>
     */
    const GAUGE_DOUBLE = 2;
    /**
     * Distribution gauge measurement. The count and sum can go both up and
     * down. Recorded values are always >= 0.
     * Used in scenarios like a snapshot of time the current items in a queue
     * have spent there.
     *
     * Generated from protobuf enum <code>GAUGE_DISTRIBUTION = 3;</code>
     */
    const GAUGE_DISTRIBUTION = 3;
    /**
     * Integer cumulative measurement. The value cannot decrease, if resets
     * then the start_time should also be reset.
     *
     * Generated from protobuf enum <code>CUMULATIVE_INT64 = 4;</code>
     */
    const CUMULATIVE_INT64 = 4;
    /**
     * Floating point cumulative measurement. The value cannot decrease, if
     * resets then the start_time should also be reset. Recorded values are
     * always >= 0.
     *
     * Generated from protobuf enum <code>CUMULATIVE_DOUBLE = 5;</code>
     */
    const CUMULATIVE_DOUBLE = 5;
    /**
     * Distribution cumulative measurement. The count and sum cannot decrease,
     * if resets then the start_time should also be reset.
     *
     * Generated from protobuf enum <code>CUMULATIVE_DISTRIBUTION = 6;</code>
     */
    const CUMULATIVE_DISTRIBUTION = 6;
    /**
     * Some frameworks implemented Histograms as a summary of observations
     * (usually things like request durations and response sizes). While it
     * also provides a total count of observations and a sum of all observed
     * values, it calculates configurable percentiles over a sliding time
     * window. This is not recommended, since it cannot be aggregated.
     *
     * Generated from protobuf enum <code>SUMMARY = 7;</code>
     */
    const SUMMARY = 7;

    private static $valueToName = [
        self::UNSPECIFIED => 'UNSPECIFIED',
        self::GAUGE_INT64 => 'GAUGE_INT64',
        self::GAUGE_DOUBLE => 'GAUGE_DOUBLE',
        self::GAUGE_DISTRIBUTION => 'GAUGE_DISTRIBUTION',
        self::CUMULATIVE_INT64 => 'CUMULATIVE_INT64',
        self::CUMULATIVE_DOUBLE => 'CUMULATIVE_DOUBLE',
        self::CUMULATIVE_DISTRIBUTION => 'CUMULATIVE_DISTRIBUTION',
        self::SUMMARY => 'SUMMARY',
    ];

    public static function name($value)
    {
        if (!isset(self::$valueToName[$value])) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no name defined for value %s', __CLASS__, $value));
        }
        return self::$valueToName[$value];
    }


    public static function value($name)
    {
        $const = __CLASS__ . '::' . strtoupper($name);
        if (!defined($const)) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no value defined for name %s', __CLASS__, $name));
        }
        return constant($const);
    }
}

// Adding a class alias for backwards compatibility with the previous class name.
class_alias(Type::class, \Opencensus\Proto\Metrics\V1\MetricDescriptor_Type::class);

